---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

<!-- devtools::build_readme() -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
options(width = 94)
```

# champsmortality

<!-- badges: start -->
<!-- badges: end -->

The goal of champsmortality is to provide functions for calculating mortality fractions and rates at CHAMPS sites for various causes.

## Installation

You can install the development version of champsmortality with the following:

``` r
install.packages("remotes") # one time only
remotes::install_github("ki-tools/champsmortality")
```

## Example

```{r}
library(champsmortality)
```

### Data setup

The first time you use this package, you need to place the appropriate data files in a data directory that the package will pull from to perform the calculations. A function `create_dataset_directory()` is provided to help get this set up.

```{r strip.white=FALSE}
data_dir <- tempfile()
create_dataset_directory(data_dir)
```

This is something that only needs to be done once.

### Read the data

Once this is set up and the appropriate files are placed and mapped in the `config.yaml` file, you can read in the data with the following:

```{r echo=FALSE}
data_dir <- "_ignore/datasets"
```

```{r}
d <- read_and_validate_data(data_dir)
```

This will read in the data files and ensure that all of the variables required to perform the calculations are present. If they are not, you will see an error message and will need to correct the error before being able to use the package.

### Process the data

A function, `process_data()` takes the data that has been read and joins it together to create an analysis dataset and DSS dataset ready for analysis.
```{r}
dd <- process_data(d, start_year = 2017, end_year = 2020)
```

### Computing statistics

We will use the `dplyr` package for some of the examples below so let's load it:

```{r message=FALSE}
library(dplyr)
```

#### Tables of MITS / non-MITS+DSS-only counts by site and factor

A function `mits_selection_factor_tables()` exists in this package that computes tables of MITS / non-MITS+DSS-only counts by site and factor and associated statistics.

This function aims to replicate table 5a in "Supplemental Results (OLD)" as part of determining what factors to adjust for.

To call the function for sites "Bangladesh", "Ethiopia", "Kenya" and their associated catchments:

```{r}
fac_tbl <- mits_selection_factor_tables(dd,
  sites = c("Bangladesh", "Ethiopia", "Kenya"),
  catchments = c("Baliakandi", "Haramaya", "Harar", "Kersa",
    "Manyatta", "Siaya")
)
```

The output looks like this:

```{r}
print(fac_tbl, n = 21)
```

Each row is for one site/factor combination and contains the table of counts (as a nested data frame), the p-value of the chi-square test, and percent missing values.

To view the table of counts for the first record (Bangladesh/age):

```{r}
fac_tbl$table[[1]]
```

To see the table of counts for a specific record (e.g. Bangladesh/location):

```{r}
filter(fac_tbl, site == "Bangladesh", factor == "location")$table
```

To look at which sites/factors pass the adjustment criterion, we can filter the table based on these:

```{r}
filter(fac_tbl, pval < 0.1, pct_na < 20)
```

Suppose we want to compute the table separately for just one site in Kenya:

```{r}
# compute just for Kenya/Manyatta
ke_man_tbl <- mits_selection_factor_tables(dd,
  sites = "Kenya",
  catchments = "Manyatta"
)
```

The by-age table:

```{r}
ke_man_tbl$table[[1]]
```

#### Tables of MITS cases with and without a specified condition by factor

Another table used to determine what factors to adjust for is MITS cases with and without the condition for which we are calculating mortality for by factor. This can be computed using `cc_factor_tables()`.

It has the same arguments as the previous function but also has the `champs_group` argument that we use do define the cause we want to compute the statistics for.

```{r}
# table of MITS cases with and without a specified condition by factor
cbd_tbl <- cc_factor_tables(dd,
  sites = c("Bangladesh", "Ethiopia", "Kenya"),
  catchments = c("Baliakandi", "Haramaya", "Harar", "Kersa",
    "Manyatta", "Siaya"),
  champs_group = "Congenital birth defects"
)
```

The output structure is similar as shown before:

```{r}
cbd_tbl
```

The table for Bangladesh/age:

```{r}
cbd_tbl$table[[1]]
```

Which sites/factors pass the adjustment criterion:

```{r}
filter(cbd_tbl, pval < 0.1, pct_na < 20)
```

#### Ad hoc computations

The following code can be used to compute the total number of deaths in Baliakandi Bangladesh, by age and MITS and non-MITS+DSS-only. This is part of the computation that is provided automatically by `mits_selection_factor_tables()` described above.

```{r}
bind_rows(
  dd$ads %>%
    filter(site == "Bangladesh", catchment == "Baliakandi") %>%
    count(mits_flag, age),
  dd$dss %>%
    filter(site == "Bangladesh", catchment == "Baliakandi",
      factor == "age") %>%
    group_by(level) %>%
    summarise(n = sum(n)) %>%
    rename(age = "level") %>%
    mutate(mits_flag = 0)
) %>%
  group_by(mits_flag, age) %>%
  summarise(n = sum(n), .groups = "drop")
```

The following computes the number of MITS deaths with and without neural tube defects and congenital birth defects by age. This uses functions `has_icd10_cc()` to check if neural tube defects are in the causal chain using a regular expression indicating ICD10, and `has_champs_group_cc()` to check if congenital birth defects are in the causal chain using a CHAMPS group.

```{r}
cbd_ntd <- dd$ads %>%
  mutate(
    ntd_cc = has_icd10_cc(., "^Q00|^Q01|^Q05"),
    cbd_cc = has_champs_group_cc(., "Congenital birth defects")
  )

cbd_ntd %>%
  filter(site == "Bangladesh", catchment == "Baliakandi") %>%
  count(cbd_cc, age) %>%
  filter(!is.na(cbd_cc)) %>%
  arrange(cbd_cc, age)
```

This code is part of the calculations of mortality rates and fractions automatically provided by the function `cc_factor_tables()` described previously.

More to come...

